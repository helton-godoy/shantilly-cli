#!/usr/bin/env node
/**
 * scripts/agent-doc.js
 * Extracts semantic tags (@ai-invariant, @ai-context, @ai-connection) from code
 * and generates docs/architecture/SYSTEM_MAP.md.
 */
const fs = require('fs');
const path = require('path');

const CONFIG = {
    include: ['.js', '.ts', '.jsx', '.tsx', '.py', '.rb', '.go', '.rs'],
    exclude: ['node_modules', 'dist', 'build', 'coverage', '.git'],
    outputFile: 'docs/architecture/SYSTEM_MAP.md'
};

function scanDir(dir, fileList = []) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (CONFIG.exclude.some(ex => filePath.includes(ex))) return;

        if (stat.isDirectory()) {
            scanDir(filePath, fileList);
        } else {
            if (CONFIG.include.includes(path.extname(file))) {
                fileList.push(filePath);
            }
        }
    });
    return fileList;
}

function extractTags(content) {
    const tags = [];
    // Regex to match block comments /** ... */
    const commentRegex = /\/\*\*([\s\S]*?)\*\//g;
    let match;

    while ((match = commentRegex.exec(content)) !== null) {
        const commentBlock = match[1];

        // Extract specific tags
        const tagTypes = ['ai-invariant', 'ai-context', 'ai-connection'];
        tagTypes.forEach(type => {
            const tagRegex = new RegExp(`@${type}\\s+(.*)`, 'g');
            let tagMatch;
            while ((tagMatch = tagRegex.exec(commentBlock)) !== null) {
                tags.push({
                    type: type,
                    content: tagMatch[1].trim()
                });
            }
        });
    }
    return tags;
}

function generateMarkdown(mapData) {
    let md = '# SYSTEM MAP (AgentDoc)\n\n';
    md += '> Auto-generated by `npm run bmad:doc`. DO NOT EDIT MANUALLY.\n\n';
    md += 'This document maps the semantic context, invariants, and connections of the codebase.\n\n';

    if (Object.keys(mapData).length === 0) {
        md += '*No AgentDoc tags found yet. Start adding `@ai-context` to your code!*';
        return md;
    }

    for (const [file, tags] of Object.entries(mapData)) {
        if (tags.length === 0) continue;

        md += `## ðŸ“„ \`${file}\`\n`;

        const context = tags.filter(t => t.type === 'ai-context');
        const invariants = tags.filter(t => t.type === 'ai-invariant');
        const connections = tags.filter(t => t.type === 'ai-connection');

        if (context.length > 0) {
            md += '### ðŸ§  Context\n';
            context.forEach(t => md += `- ${t.content}\n`);
        }

        if (invariants.length > 0) {
            md += '### ðŸ›¡ï¸ Invariants (DO NOT BREAK)\n';
            invariants.forEach(t => md += `- ðŸ”´ **${t.content}**\n`);
        }

        if (connections.length > 0) {
            md += '### ðŸ”— Connections\n';
            connections.forEach(t => md += `- âž¡ï¸ ${t.content}\n`);
        }
        md += '\n---\n\n';
    }
    return md;
}

// Main Execution
console.log('\x1b[36mðŸ§  AgentDoc: Scanning codebase...\x1b[0m');
const rootDir = process.cwd();
const files = scanDir(rootDir);
const mapData = {};

files.forEach(file => {
    const content = fs.readFileSync(file, 'utf-8');
    const tags = extractTags(content);
    if (tags.length > 0) {
        const relativePath = path.relative(rootDir, file);
        mapData[relativePath] = tags;
    }
});

const output = generateMarkdown(mapData);
const outputPath = path.join(rootDir, CONFIG.outputFile);

// Ensure dir exists
const outputDir = path.dirname(outputPath);
if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

fs.writeFileSync(outputPath, output);
console.log(`\x1b[32mâœ… System Map generated at: ${CONFIG.outputFile}\x1b[0m`);
