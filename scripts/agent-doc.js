#!/usr/bin/env node
/**
 * scripts/agent-doc.js
 * Extracts semantic tags (@ai-invariant, @ai-context, @ai-connection) from code
 * and generates docs/architecture/SYSTEM_MAP.md.
 */
const fs = require('fs');
const path = require('path');

const CONFIG = {
    include: ['.js', '.ts', '.jsx', '.tsx', '.py', '.rb', '.go', '.rs'],
    exclude: ['node_modules', 'dist', 'build', 'coverage', '.git'],
    outputFile: 'docs/architecture/SYSTEM_MAP.md'
};

function scanDir(dir, fileList = []) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (CONFIG.exclude.some(ex => filePath.includes(ex))) return;

        if (stat.isDirectory()) {
            scanDir(filePath, fileList);
        } else {
            if (CONFIG.include.includes(path.extname(file))) {
                fileList.push(filePath);
            }
        }
    });
    return fileList;
}

function extractTags(content) {
    const tags = [];
    // Regex to match block comments /** ... */
    const commentRegex = /\/\*\*([\s\S]*?)\*\//g;
    let match;

    while ((match = commentRegex.exec(content)) !== null) {
        const commentBlock = match[1];

        // Extract specific tags
        const tagTypes = ['ai-invariant', 'ai-context', 'ai-connection'];
        tagTypes.forEach(type => {
            const tagRegex = new RegExp(`@${type}\\s+(.*)`, 'g');
            let tagMatch;
            while ((tagMatch = tagRegex.exec(commentBlock)) !== null) {
                tags.push({
                    type: type,
                    content: tagMatch[1].trim()
                });
            }
        });
    }
    return tags;
}

function generateMarkdown(mapData) {
    let md = `# SYSTEM MAP (AgentDoc)\n\n`;
    md += `> Auto-generated by \`npm run bmad:doc\`. DO NOT EDIT MANUALLY.\n\n`;
    md += `This document maps the semantic context, invariants, and connections of the codebase.\n\n`;

    if (Object.keys(mapData).length === 0) {
        md += `*No AgentDoc tags found yet. Start adding \`@ai-context\` to your code!*`;
        return md;
    }

    for (const [file, tags] of Object.entries(mapData)) {
        if (tags.length === 0) continue;

        md += `## üìÑ \`${file}\`\n`;

        const context = tags.filter(t => t.type === 'ai-context');
        const invariants = tags.filter(t => t.type === 'ai-invariant');
        const connections = tags.filter(t => t.type === 'ai-connection');

        if (context.length > 0) {
            md += `### üß† Context\n`;
            context.forEach(t => md += `- ${t.content}\n`);
        }

        if (invariants.length > 0) {
            md += `### üõ°Ô∏è Invariants (DO NOT BREAK)\n`;
            invariants.forEach(t => md += `- üî¥ **${t.content}**\n`);
        }

        if (connections.length > 0) {
            md += `### üîó Connections\n`;
            connections.forEach(t => md += `- ‚û°Ô∏è ${t.content}\n`);
        }
        md += `\n---\n\n`;
    }
    return md;
}

// Qdrant Configuration
const QDRANT_URL = 'http://localhost:6333';
const COLLECTION_NAME = 'bmad_agent_memory';

async function qdrantRequest(endpoint, method = 'GET', body = null) {
    try {
        const options = {
            method,
            headers: { 'Content-Type': 'application/json' }
        };
        if (body) options.body = JSON.stringify(body);

        const response = await fetch(`${QDRANT_URL}${endpoint}`, options);
        return await response.json();
    } catch (e) {
        console.error(`‚ùå Qdrant Error (${endpoint}):`, e.message);
        return null;
    }
}

async function ensureCollection() {
    const collections = await qdrantRequest('/collections');
    const exists = collections?.result?.collections?.some(c => c.name === COLLECTION_NAME);

    if (!exists) {
        console.log(`‚öôÔ∏è Creating Qdrant collection: ${COLLECTION_NAME}`);
        await qdrantRequest(`/collections/${COLLECTION_NAME}`, 'PUT', {
            vectors: { size: 384, distance: 'Cosine' } // Using 384 for standard small models (all-MiniLM-L6-v2)
        });
    }
}

// Simple mock embedding for demonstration (In production, use a local model or API)
// This creates a deterministic "fake" vector based on string content to allow storage testing
function mockEmbedding(text) {
    const vector = new Array(384).fill(0);
    for (let i = 0; i < text.length; i++) {
        vector[i % 384] = (vector[i % 384] + text.charCodeAt(i)) / 255; // Normalize roughly
    }
    return vector;
}

async function syncToQdrant(mapData) {
    await ensureCollection();

    const points = [];
    let idCounter = Date.now();

    for (const [file, tags] of Object.entries(mapData)) {
        for (const tag of tags) {
            points.push({
                id: idCounter++,
                vector: mockEmbedding(tag.content),
                payload: {
                    file: file,
                    type: tag.type,
                    content: tag.content,
                    project: path.basename(process.cwd())
                }
            });
        }
    }

    if (points.length > 0) {
        console.log(`üöÄ Sending ${points.length} points to Qdrant...`);
        const result = await qdrantRequest(`/collections/${COLLECTION_NAME}/points?wait=true`, 'PUT', {
            points: points
        });
        if (result?.status === 'ok') {
            console.log(`‚úÖ Qdrant Sync Successful!`);
        } else {
            console.error(`‚ùå Qdrant Sync Failed:`, result);
        }
    }
}

// Main Execution
(async () => {
    console.log("\x1b[36müß† AgentDoc: Scanning codebase...\x1b[0m");
    const rootDir = process.cwd();
    const files = scanDir(rootDir);
    const mapData = {};

    files.forEach(file => {
        const content = fs.readFileSync(file, 'utf-8');
        const tags = extractTags(content);
        if (tags.length > 0) {
            const relativePath = path.relative(rootDir, file);
            mapData[relativePath] = tags;
        }
    });

    // 1. Generate Markdown (Legacy/Quick View)
    const output = generateMarkdown(mapData);
    const outputPath = path.join(rootDir, CONFIG.outputFile);
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });
    fs.writeFileSync(outputPath, output);
    console.log(`\x1b[32m‚úÖ System Map generated at: ${CONFIG.outputFile}\x1b[0m`);

    // 2. Sync to Qdrant (Vector Memory)
    if (process.argv.includes('--qdrant')) {
        await syncToQdrant(mapData);
    } else {
        console.log(`‚ÑπÔ∏è  Run with --qdrant to sync with Vector Database.`);
    }
})();
